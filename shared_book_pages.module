<?php

function shared_book_pages_entity_load(array $entities, $type) {
  if ($type != 'node') {
    return;
  }
  foreach ($entities as $entity) {
    if ($entity->type !== 'book') {
      return;
    }
    if (count($entity->field_shared_book_page) != 1) {
      return;
    }
    // the source node should not be tagged with it's own nid, but in case it is, bail out to prevent infinite loop!
    //TODO: support locale
    $term = taxonomy_term_load($entity->field_shared_book_page[LANGUAGE_NONE][0]['tid']);
    if (!$term) {
      return;
    }
    $eid = intval($term->name);
    if ($eid == $entity->nid) {
      return;
    }
    //TODO: Can the source node be tagged with the nid of a source-source-node? Use a static variable to make that illegal? Performance...
    /*
     * Chains of shared pages work e.g. 53194 references 53193 which references 53750
     */
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'book')
      ->entityCondition('entity_id', $eid, '=');
    $result = $query->execute();
    if (isset($result['node'])) {
      $source_nid = array_keys($result['node']);
      $source_node = entity_load('node', array($source_nid[0]));
      $entity->title = $source_node[$eid]->title;
      $entity->body = $source_node[$eid]->body;
    }
  }
}

function shared_book_pages_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case "book_node_form":
      if ($form['#node_edit_form'] == !TRUE) {
        return;
      }
      /*
       * Alter the edit form just on nodes with values in field_shared_book_page
       */
      if (!empty($form['field_shared_book_page'][LANGUAGE_NONE]['#default_value'])) {
        $nid = $form['field_shared_book_page'][LANGUAGE_NONE]['#default_value'];
        $form_state['process_input'] = FALSE;
        // TODO: Arbitrary fields could be added, which should be filtered?
        $form['title']['#access'] = FALSE;
        $form['body']['#access'] = FALSE;
        $form['shared_page'] = array(
          '#type' => 'item',
          '#title' => "This is a shared page",
          '#markup' => "This page is used in multiple books.  To edit it please " . l("edit the source content", 'node/' . $nid . '/edit'),
        );
      }
      /*
       * Add custom validation callback on all book nodes
       */
      array_push($form['#validate'], 'shared_book_pages_validate');
      break;
  }
}

/**
 * Implementation of hook_menu_alter
 * @param $items
 *
 * Don't display the shared book in the list of books.
 */
function shared_book_pages_menu_alter(&$items) {
  $items['book'] = array(
    'title' => 'Books',
    'page callback' => 'shared_book_pages_book_render',
    'access arguments' => array('access content'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => '',
  );
}

/**
 * Menu callback: Prints a listing of all books.
 *
 * @return string
 *   A HTML-formatted string with the listing of all books content.
 *
 * @see book_menu()
 */
function shared_book_pages_book_render() {
  require_once(drupal_get_path('module', 'book') . "/book.module");
  $shared_book_title = variable_get('shared_book_title', 'Shared Book Pages');
  $book_list = array();
  foreach (book_get_books() as $book) {
    if ($book['title'] != $shared_book_title) {
      $book_list[] = l($book['title'], $book['href'], $book['options']);
    }
  }
  return theme('item_list', array('items' => $book_list));
}

/**
 * Form validation handler for node_form().
 *
 * @see shared_book_pages_form_alter()
 * @see node_form()
 * @see node_form_submit()
 */
function shared_book_pages_validate($form, &$form_state) {
  $references = shared_book_pages_get_references($form['nid']['#value']);
  $requested_refereneced_nid = NULL;
  if (count($form_state['values']['field_shared_book_page'][LANGUAGE_NONE]) > 0) {
    $requested_refereneced_nid = $form_state['values']['field_shared_book_page'][LANGUAGE_NONE][0]['name'];
  }
  if (in_array($requested_refereneced_nid, array_keys($references['node']))) {
    form_set_error('field_shared_book_page', t("The page ". shared_book_pages_get_linked_title($requested_refereneced_nid) . " (node_id = %nid) already references <em>this</em> node. Referencing that node would create a circular reference which we cannot allow.", array('%nid' => $requested_refereneced_nid)));
  }
}

function shared_book_pages_get_references($nid) {
  // get the vid for the vocabulary
  $vocab = taxonomy_vocabulary_machine_name_load(variable_get('shared_book_pages_vocabulary', 'shared_book_pages'));
  // Get all term objects in shared pages vocabulary
  $terms = taxonomy_get_tree($vocab->vid);
  // Find the term_id for this $nid. Should only be 1, but if multiple, first one wins
  // (Might be better to use real db tables)
  $tid = NULL;
  foreach ($terms as $term) {
    if ($term->name == $nid) {
      $tid = $term->tid;
      break;
    }
  }
  if ($tid === NULL) {
    // There are no references to this nid i.e. no nodes that share its content
    return array();
  }
  // Find all entities referencing this the term_id of our nid.
  $nodeQuery = new EntityFieldQuery();
  $entities = $nodeQuery->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'book')
    // ->propertyCondition('status', 1) //Look for published or unpublished pages
    ->fieldCondition('field_shared_book_page', 'tid', $tid)
    ->execute();
  return $entities;
}

function shared_book_pages_get_linked_title($nid, $target_new = TRUE) {
  $node = node_load($nid);
  if ($target_new) {
    $link = l($node->title, "node/" . $node->nid, array('attributes' => array('target' => '_new')));
  }
  else {
    l($node->title, "node/" . $node->nid);
  }
  return $link;
}

/**
 * Implementation of hook_node_update
 */

function shared_book_pages_node_update($node) {
  if ($node->type == 'book') {
    // Act on the unpublishing
    if ($node->original->status == 1 && $node->status == 0) {
      $references = shared_book_pages_get_references($node->nid);
      if (count($references['node'] > 0)) {
        $html = "<ul>\n";
        foreach ($references['node'] as $node) {
          $html .= "<li>" . shared_book_pages_get_linked_title($node->nid) . "</li>\n";
        }
        $html .= "</ul>\n";
      }
      drupal_set_message("The following nodes reference this page: $html. Even though this pages is now unpublished, those nodes will still display the content of this page.", "warning");
    }
  }
}
